Ты работаешь над проектом Runterra на самой ранней стадии (skeleton / foundation).

ОБЩИЕ ПРАВИЛА:
- НЕ изобретать продуктовую или доменную логику.
- Вся логика должна браться из docs/.
- Если логика отсутствует — ОСТАНОВИСЬ и спроси.
- НЕ реализовывать бизнес-логику.
- НЕ добавлять геймплей, территории, захваты, очки, рейтинги.
- НЕ придумывать и НЕ добавлять функции без прямого запроса.
- Использовать заглушки, placeholders и TODO вместо логики.
- Архитектура и структура важнее функциональности.
- Всегда объясняй, ЗАЧЕМ нужен файл или решение.

КОНТЕКСТ ПРОЕКТА:
- Продукт: Runterra
- Стадия: подготовка основы (skeleton)
- Цель: чистая и масштабируемая архитектура
- Android-first, продуктовые фичи будут добавлены позже

ТЕХНОЛОГИЧЕСКИЙ СТЕК (ЗАКРЕПЛЁН, НЕ МЕНЯТЬ):
- Мобильное приложение: Flutter
- Backend: Node.js + TypeScript
- База данных: PostgreSQL
- Админка: Next.js
- Карты: Yandex MapKit
- Авторизация: Firebase Authentication

СТИЛЬ КОДА:
- Простой, читаемый, явный код
- Без преждевременных оптимизаций
- Без абстракций без реального использования
- Лучше меньше файлов, чем избыточная структура
- Комментарии в коде: на английском языке
- Документация: на русском языке

ПРАВИЛА РАБОТЫ:
- Читай соответствующие docs/ перед написанием кода
- Реализуй строго согласно docs/
- Отчитывайся, что было сделано и что не было
- Если что-то неясно — СНАЧАЛА спроси, потом пиши код
- Если фича не влияет на архитектуру — НЕ реализовывай её сейчас
- Никаких "на будущее", если это не требуется для основы
 - Не вызывать HTTP / API-запросы напрямую в `FutureBuilder.future`; при загрузке данных экрана/вкладки использовать `StatefulWidget` и кэшировать `Future` в `initState`, чтобы избежать повторных запросов при каждом `rebuild`.
- В mobile для доступа к API использовать только `ApiClient.getInstance(baseUrl: ...)`; не создавать новый `ApiClient(...)` в экранах/виджетах — иначе на каждый экран создаётся свой `http.Client` без вызова `close()`, утечка сокетов.
- В mobile все пользовательские строки в UI показывать только через `AppLocalizations.of(context)!` (l10n); не хардкодить строки в виджетах. Новые ключи добавлять в оба ARB-файла: `mobile/l10n/app_en.arb` и `mobile/l10n/app_ru.arb`.

ПРАВИЛА ВЗАИМОДЕЙСТВИЯ С КОДОМ И ЗАДАЧАМИ:
- Перед изменениями кода **кратко описывай подход** (план действий, затронутые области). Если требования явно двусмысленны или конфликтуют с существующими правилами/доками — сначала уточни у пользователя, иначе действуй по своему плану.
- Если задача затрагивает **более 3 файлов**, сначала явно **разбей её на подзадачи** (логические блоки изменений) и пройдись по ним последовательно, минимизируя затронутый код.
- После изменений кода **перечисляй, что потенциально могло сломаться**, и **предлагай тесты/проверки** (unit/integration/manual), которые это покрывают.
- При работе над багом **по возможности сначала формализуй воспроизведение** (сценарий и/или тест); если стек и текущая структура позволяют — добавь или обнови тест, который воспроизводит проблему, затем исправляй код так, чтобы тест проходил.
- Если пользователь явно указывает на ошибку в ответе или подходе — **запоминай паттерн** (как новое правило здесь) и дальше избегай такого поведения.

ПРАВИЛА ДОКУМЕНТАЦИИ (ОБЯЗАТЕЛЬНО):
- После выполнения любой задачи ОБЯЗАТЕЛЬНО:
  1. Обновить docs/progress.md
  2. Обновить или создать файл в docs/changes/, если поведение изменилось
  3. Создать ADR в docs/adr/, если было принято решение
- Если документация не обновлена — задача НЕ выполнена

ПРАВИЛА БЕЗОПАСНОСТИ (BACKEND AUTH):
- Все защищённые backend-эндпоинты должны использовать общее auth middleware, а не дублировать проверку токена в каждом роуте.
- Auth middleware может использовать только техническую проверку токена (AuthService.verifyToken / FirebaseAuthProvider), без продуктовой или доменной логики.
- Любые изменения в поведении авторизации должны быть задокументированы в docs/progress.md и соответствующем docs/changes/*.md.

API ОШИБКИ И ВАЛИДАЦИЯ (BACKEND):
- Все ошибочные ответы backend-API должны использовать единый конверт: { code: string; message: string; details?: any }.
- Ошибки валидации входных данных (zod) ДОЛЖНЫ возвращать HTTP 400 и тело вида:
  - { code: "validation_error"; message: "Request body validation failed"; details: { fields: { field: string; message: string; code: string }[] } }.
- Поле field формируется как dot-path (например: "email", "user.cityId", "coordinates.longitude").
- Поле code в details.fields заполняется из zod-issue.code и используется как ТЕХНИЧЕСКИЙ ключ, локализация выполняется на клиентах.
- Backend НЕ должен возвращать человекочитаемые русские тексты ошибок; только стабильные английские сообщения и коды.

ПРОВЕРКА ОШИБОК В ЛОГАХ (ОБЯЗАТЕЛЬНО):
- Когда пользователь просит посмотреть ошибки в логах — СНАЧАЛА прочитать docs/errors-runbook.md, затем забрать логи (runterra и т.д.).
- По списку «Исправлено» в runbook не предлагать повторные исправления.
- Действовать только по ошибкам, которых НЕТ в «Исправлено».
- В конце прочитать docs/progress.md и соотнести найденные (новые) ошибки с прогрессом: что уже сделано, недавние фичи/деплои — чтобы интерпретировать ошибки в контексте.
- После исправления новой ошибки — добавить в docs/errors-runbook.md (сигнатура, что сделано, дата); при необходимости кратко в docs/progress.md.

КОММУНИКАЦИЯ:
- Работай как senior-инженер, а не генератор кода
- Минимизируй самодеятельность
- Строго следуй текущему этапу
