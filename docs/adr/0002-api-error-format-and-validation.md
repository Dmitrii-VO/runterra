# ADR-0002: Единый формат ошибок API и политика runtime-валидации

## Контекст

Backend проекта Runterra на skeleton-этапе уже использует TypeScript DTO и Zod для runtime-валидации тел POST-запросов, а также общее middleware авторизации (`authMiddleware`) для всех `/api` роутов.

Ранее:

- Ошибки валидации возвращались в виде произвольного JSON (`{ error, issues }`).
- Ошибки авторизации возвращались с разными формами (`{ error: string }`), без единого контракта.
- Локализация и обработка ошибок на клиентах (mobile/admin) не имели единых технических опор (код-ключи, структура details).

Необходимо определить стабильный, расширяемый формат ошибок API и общую политику runtime-валидации, не затрагивая бизнес-логику и доменные правила.

## Решение

1. **Единый конверт ошибок API**

   Все ошибочные ответы backend-API используют формат:

   - `code: string` — стабильный машинный код ошибки (например: `validation_error`, `unauthorized`, `not_found`, `internal_error`).
   - `message: string` — краткое техническое сообщение на английском языке (для логов и отладки).
   - `details?: any` — дополнительная информация, зависящая от типа ошибки.

   HTTP-статус (`400/401/403/404/500` и т.д.) остаётся основным носителем семантики, а `code` описывает тип ошибки на уровне API-слоя, не доменную логику.

2. **Ошибки валидации (Zod)**

   Для runtime-валидации тела запроса через Zod:

   - HTTP статус: `400 Bad Request`.
   - Тело ответа:

     ```json
     {
       "code": "validation_error",
       "message": "Request body validation failed",
       "details": {
         "fields": [
           {
             "field": "path.to.field",
             "message": "Zod message",
             "code": "zod_issue_code"
           }
         ]
       }
     }
     ```

   - `fields` формируется маппингом `ZodIssue`:
     - `field` = `issue.path.join('.')`.
     - `message` = `issue.message` (английский, технич.).
     - `code` = `issue.code` (используется как технический ключ).

3. **Ошибки авторизации (`authMiddleware`)**

   Для всех ошибок авторизации используется:

   - HTTP статус: `401 Unauthorized`.
   - Тело ответа:

     ```json
     {
       "code": "unauthorized",
       "message": "Authorization required",
       "details": {
         "reason": "missing_header" | "invalid_format" | "invalid_token" | "unexpected_error"
       }
     }
     ```

4. **Политика runtime-валидации**

   На skeleton-этапе runtime-валидация на backend ограничивается:

   - Проверкой формы и типов входных данных (в первую очередь `req.body`) через Zod-схемы (`Create*Schema` рядом с DTO).
   - Без доменных инвариантов и бизнес-логики (связи сущностей, статусы, условия захвата территорий и т.п.).

   Правила:

   - Все новые входящие DTO должны иметь Zod-схему (например, `CreateUserDto` + `CreateUserSchema`).
   - Ошибки валидации тела → HTTP `400` + `code: "validation_error"` + `details.fields`.
   - Ошибки авторизации (отсутствие/неверный формат заголовка/невалидный токен) → HTTP `401` + `code: "unauthorized"` + `details.reason`.

5. **Локализация**

   - Backend возвращает только технические коды и английские сообщения.
   - Русскоязычные тексты и UX-сообщения формируются на клиентах (mobile/admin) на основе:
     - HTTP статуса,
     - `code`,
     - `details` (например, `fields` или `reason`).

## Альтернативы

- Продолжать использовать произвольные структуры ошибок (`{ error: string }`), полагаясь только на HTTP-статус:
  - Минусы: сложно централизованно обрабатывать ошибки на клиентах, нет стабильных ключей для локализации и аналитики.

- Возвращать локализованные (русские) сообщения прямо с backend:
  - Минусы: смешивание ответственности (backend начинает отвечать за продуктовую локализацию), усложнение поддержки нескольких языков, нарушение текущих правил проекта (локализация на клиентах).

## Последствия

Положительные:

- Единый предсказуемый контракт для обработки ошибок во всех клиентах.
- Простая интеграция Zod-валидации с фронтендом через `details.fields`.
- Возможность строить аналитику по кодам ошибок (`code`, `fields[*].code`).

Ограничения:

- Требуется придерживаться выбранного формата в новых эндпоинтах и middleware.
- Любые изменения в структуре ошибок должны проходить через обновление этой ADR и документации.

## Статус

Accepted.

